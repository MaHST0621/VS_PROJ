[TOC]
##  聊天协议
### 语法  
1. 输入时必须要输入发送对象的昵称 [^注1] 而且是在第一个冒号之前***recv:message***。
2. 想对多个对象发消息时必须要把每个对象昵称用‘|’来分割开***user1_name \| user2_name:message***. 
3. 收到消息时客户端将会打印出***[user_name]:message***。


### 语义  
1. 点开客户端后必须发送一条SENDBUFF为自己取个昵称，当服务端接收到改昵称后会把该SOCKET 与昵称放在一个全局map[^注2]里。然后给所有的客户端提示 ***"欢迎 username 加入该服务器"*** 并为该用户显示服务器在线人员。
2. 如果在建立映射关系时发现该昵称已被该服务器在线的人所使用，它就不会把它存到map里而是给该SOCKET发个提示说该昵称已被使使用请重新链接之后关闭该线程和SOCKET。
3. 服务端接受到消息后会对RECVBUFF进行接受对象和发送信息的分离操作。
    * 通过**find_SendId()**函数从RECVBUFF中提取该消息接受对象的昵称。
    * 通过**cut_buff()**函数从RECVBUFF中提取消息部分。
    * 通过第一步提取出来的用户名一个一个映射出接收者的SOCKET来发消息。
2. 发送对象为该服务器的所有人时我们只要在冒号前面写个***all***就可以，然后服务端会把消息发送给所有map里现存的用户。
3. 当服务器发现某一消息的接受者昵称不在map里，那么服务器会给发送者一个该用户不存在的消息。
4. 当RECVBUFF等于"quit"时，表示该客户端想要退出服务，那么这时候先会给所有其他的用户发送该用户退出服务器的消息然后把给用户的昵称和SOCKET从map里删除，最后才把SOCKET给关掉。


### 时序  
##### 客户端
1. 给想要链接的服务器发送**connect**请求。
2. 生成一个新的线程来为自己接受消息并打印到客户端界面。
3. 进入循环用**cin.getline()**来输入SENDBUFF并把消息发出去。



##### 服务器端
1. 与客户端不同的就是服务端在初始化完后主线程就进入了一个循环来不断地监听该SOCKET收到的**connect**请求。
2. **accept**成功后它会生成一个新的SOCKET并把它放入一个新的线程作为参数。
3. 进入新的线程后它就把该SOCKET收到的第一个RECVBUFF[^注3]与该SOCKET建立起一个映射关系并存到全局map里。
4. 进入循环并不断的处理RECVBUFF来执行相应的文本处理和发送消息功能。

[^注1]:无论什么时候昵称后面不能有空格。
[^注2]:key->user_name,value->socket
[^注3]:客户端作为昵称传过来的消息。
